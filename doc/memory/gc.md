-----------------------------------------------------------------------------------------------
# Reclamation (Garbage Collection)



..... _reclamation_, or _garbage collection_, .....



Dynamically allocated objects may be explicitly deallocated (using `Unchecked_Deallocation`), 
in order to immediately make the memory space they take up ready for re-use, but ......







-----------------------------------------------------------------------------------------------
## 






The [PXC](../pxcr/PXC.md) instructions generated by the [Realizor](../pxcr/Realizor.md) 
include _garbage collection_ functionality, unless the pragma `Storage_Management` is used to turn off garbage collection, 









-----------------------------------------------------------------------------------------------
## Reclaimable Pools

...... abstract limited controlled `Reclaimable_Pool`, declared in the package 

?????`AdaOS.Storage_Pools`, 

derived from `Root_Storage_Pool` (also declared in `AdaOS.Storage_Pools`), .....




A reclaimable pool has three primitive operations, functions that return :

 * the total number of storage elements in the pool that have not been allocated;
 
 * the number of storage elements of the largest contiguous sequence of storage elements that 
   are not allocated. 
   
The functions are declared thus:

```ada
function Total_Free (Pool: in Reclaimable_Pool) 
   return 
      Storage_Elements.Storage_Count is abstract;

function Largest_Free (Pool: in Reclaimable_Pool) 
   return 
      Storage_Elements.Storage_Count is abstract;
```

In practice, a reclaimable pool is expected to maintain counters internally so that these 
functions can deliver their result very fast (with a minimum of instructions needing to be 
executed). 


.....

```ada
procedure Reclaim (Pool: in out Reclaimable_Pool) is abstract;
```

.....




-----------------------------------------------------------------------------------------------
## 



Prior a call to the pool's primitive operation `Allocate`, the Realizor generates instructions 
which call the pool's primitive operation `Largest_Free` to ascertain the number of storage 
elements of the largest contiguous sequence of storage elements that are not allocated. The 
result of this call will be `N1` in this document; the size (in storage elements) passed into 
the call to `Allocate` will be `N2`. 

A reclamation cycle is triggered by any one of the following situations:

 * a call to `Allocate` is about to be made but `N1 < N2` (meaning that the call to `Allocate` 
   would fail); 
   
 * a call is made to the `Reclaim` primitive operation of the pool; 
 
 * a call is made to the `Reclaim` procedure of `AdaOS.Memory` (which in turn calls `Reclaim` 
   of all extant non-empty pools); 
 
 * .....
 







-----------------------------------------------------------------------------------------------
## 





-----------------------------------------------------------------------------------------------
## 





-----------------------------------------------------------------------------------------------
## 





-----------------------------------------------------------------------------------------------
## 





-----------------------------------------------------------------------------------------------
## 








