-----------------------------------------------------------------------------------------------
# Segments

All software generated by the Realizor organises the computer's memory (main memory, RAM) into 
_segments_. A segment is a contiguous stretch of data (array of storage elements) as stored in 
memory, .....

Just about nothing is stored in memory that isn't in a segment.

There are three fundamental kinds of segment:

 * [stack segments](#stacksegs), which contain activation frames

 * [heap segments](#heapsegs), which contain storage pools

 * [module segments](#modsegs), which contain module elements

These are described in the following sections.

The module segments are classified as _static segments_, because their contents are read-only 
and are never changed after having first been created. The stack and heap segments are 
classified as _dynamic segments_ because they are read-write and their contents change 
dynamically during the execution of the system. 



-----------------------------------------------------------------------------------------------
## Stack Segments {#stacksegs}

For every task that is created (dynamically or statically), a separate _stack segment_ is 
created and mapped into memory. 

At the bottom (starting at offset 0) of the segment is a _task descriptor_, a small fixed-size
structure that contains essential metadata for the task plus any task-specific data, and then,
above the task descriptor, an array, called a _stack_, of [activation frames](.....) related to
the task. 

.....

### Task Descriptor



### Stack






-----------------------------------------------------------------------------------------------
## Heap Segments (#heapsegs)



.....



-----------------------------------------------------------------------------------------------
## Module Segments (#modsegs)

A module has one or more defined _module segments_, each identified within the module by a name 
that is an [ECLAT entity name](../intro/names.md). 

Each [element](../pxcr/modules.md#elem) of a module is allocated to one or more of the module's
segments. Each segment contains a subset of the module's elements (or all of them). It is
possible for more than one segment to contain an element, but every element must be allocated
to least one segment. 

In memory, a module segment contains the machine instructions of its subroutines and the data
of its constant data elements. Each element will be located at an offset from the start of the
segment. 

Every module segment is read-only. 

.....

An ECLAT [library](../eclat/libraries.md) contains a set of _library segments_. Each library 
segment is mapped to a module segment by a configuration item of the form:

    

    .....
    


Every library segment has a name, its _library segment name_, which is an Ada identifier and 
is a value of the enumeration type `Segment` declared in the package `System`. 



-----------------------------------------------------------------------------------------------
## Segment Classes

A _segment class_ .....

.....

A segment class `C` is declared by the configuration pragma `Segment_Class`:

    pragma Segment_Class (C);
    
The name `C` must be a legal Ada identifier. Segment class names are scoped to the entire 
library. 
    
It is harmless (but has no effect) to declare the same segment class more than once. 
    
If a segment class `C1` is to be a subclass of segment class `C2`, this can be declared as 
follows:

    pragma Segment_Class (C1);
    pragma Segment_Class (C2, Subclasses => (1 => C1));

If two different pragmas declare different subclasses of the same segment class, then the 
effect is the same as the set of all the subclasses in all the pragmas were declared. 

For example, if segment classes `C1` and 'C2' are to be subclasses of segment class `C3`, this 
can be declared as follows:

    pragma Segment_Class (C1);
    pragma Segment_Class (C2);
    pragma Segment_Class (C3, Subclasses => (C1, C2));

or alternatively as follows:

    pragma Segment_Class (C1);
    pragma Segment_Class (C2);
    pragma Segment_Class (C3, Subclasses => (1 => C1));
    pragma Segment_Class (C3, Subclasses => (1 => C2));

with exactly the same effect.

Every segment class declared in an ECLAT [library](../eclat/Libraries.md) becomes a value of 
the enumeration type `Segment_Class` declared in the package `System`. 

The function `Is_In (C1, C2)` returns `True` only if segment class `C1` is (directly or 
indirectly) a subclass of `C2`. `Is_In` is declared in the package `System`. 

There is always one segment class, named `Unsegmented`, that is implicitly declared and is
always the first value of the enumeration type `Segment_Class`. 

.....

A subprogram or named static object can be associated with a segment class named `C` if it has 
the aspect: 

    Segment_Class => C
    
A subprogram or named static object without this aspect will be implicitly associated with 
the segment class `Unsegmented`. 

A resource can be associated with a segment class by associating the object is it imported as 
with that segment class. 

.....






-----------------------------------------------------------------------------------------------
## Overlays

An _overlay_ is a set of segments. 

A assembly has one or more overlays; each overlay contains a subset (which might be the full 
set) of the segments of the assembly. A segment can be in more than one overlay, but every 
segment must be in at least one overlay. 

At any one time during the execution of ????? there is one overlay that is _present_. 

For each overlay, every segment in the overlay is associated with a memory address of the 
target machine (architecture). When the segment is loaded into memory, that address is the 
starting address at which it is loaded. 






-----------------------------------------------------------------------------------------------
## 




-----------------------------------------------------------------------------------------------
## Segmentation Plans (#segplans)

A _segmentation plan_ is a set of groups of segments, and a set of memory addresses associated 
with each group. 

No segment is in less than one group, but it is possible (and not unusual) for segment to be in 
more than one group. 

Within a group, the segments of that group are arranged in any order; it does not matter. If a 
segment is in more than one group, a copy of that segment goes into each group it is in. 

Each group is associated, by the [Realizor](../pxcr/PXCR.md), with an absolute, fixed address 
in memory. 

Whenever a group is loaded into memory, it is always loaded at the address it is associated with. 

The idea is that a group is not loaded into memory unless it is needed. The Realizor ensures 
that the necessary machine code is generated to load a group before anything in it can possibly 
be accessed (read, executed, or updated) unless the group is already loaded and valid (see 
just below). 

It is possible for two or more groups to be associated with the *same* address in memory. Such 
groups are said to be _overlaid_ with each other, and each is an _overlay_ of the others. 

If a group G1 is loaded when another group G2 overlaid with G1 has already been loaded, then G2 
is said to have been _invalidated_. Accessing anything in G1 can now occur, but if anything in 
G2 needs to be accessed, then G2 will need to be loaded again (thus invalidating G1). 

In general, if it is not safe to access something in a group (because it has never been loaded or 
because it has been invalidated by loading one of its overlays), the group is said to be 
_invalid_ (and is therefore _valid_ if it is safe). 

.....







-----------------------------------------------------------------------------------------------
## 





