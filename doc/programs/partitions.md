-----------------------------------------------------------------------------------------------
# Program Partitions

A [program](programs.md) comprises one or more _program partitions_. 

The program may be divided up into two or more partitions, that can be executed separately---in
the future they will be capable of executing on different computers in a network---but which
nevertheless form part of a single coherent program: execution of one partition would make no
sense without the concurrent execution of the other partitions of the program. 

A partition corresponds roughly to a traditional executable file of older operating systems
(including Microsoft Windows PE and Linux/ELF), but an [executable image](../pxcr/images.md)
generated by the [Realizor](../pxcr/realizor.md) can (and generally does) contain multiple
partitions. 



-----------------------------------------------------------------------------------------------
## AdaOS versus Ada Partitions

In AdaOS, a program---regardless of which programming language it is written in---comprises one
or more _program partitions_. 

The Ada programming language defines a concept of partitions, and AdaOS program partitions
corresponds directly to Ada partitions. 

For programs written in the Ada language, a partition corresponds to an ECLAT
[build partition](../eclat/building.md#part). Normally, each partition is built to produce one
module. 

For programs written in the C language, one program (in the C sense) will comprise one program
(in the AdaOS sense) which has one program partition, the [main partition](#main). 

In Ada, partitions are used as part of the [Annex E](../remcomm/remcomm.md#dsa) support for
distributed computing (one overall application executing on two or more networked computing
devices). 



-----------------------------------------------------------------------------------------------
## Partition Names {#name}

A partition is identified, within its program, by a _partition name_. 

A partition name is usually a simple name, .....





By default, the name of the [partition module](#mod) is the name of the program, with a dot
appended, and then the name of the partition appended to that. 





The name of the [main partition](#main) is always `Main`. Therefore, no other partition is
allowed to be named `Main`. 







-----------------------------------------------------------------------------------------------
## Main Partition and Main Subprogram {#main}

A program (in the AdaOS sense) always has at least one program partition, named `Main`, which
is the _main partition_ of the program. 

If the program only has one partition, then it is the main partition.

The main partition must contain the _main subprogram_ of the program, and no other partition is
allowed to contain a main subprogram. 

For an Ada program, the main partition, and only the main partition, always contains (at least)
one library-level procedure named `Main`, which must be a parameterless procedure. This is the
_main subprogram_ of the program. 

For C, the one and only partition is the main partition, and there must be one function defined
with the name `__main` (the word `main` preceded by two underscores), which is the
_main subprogram_ of the program. The standard header file `stdlib.h` supplied with ECLAT-C
contains a definition of the function `__main` which calls `main`, and takes three arguments
(`argv`, `argc`, and `env`). 

..... 






-----------------------------------------------------------------------------------------------
## 







-----------------------------------------------------------------------------------------------
## Assignment {#assign}

The library units that make up an Ada program must be _assigned_ to partitions of the program. 

If the program has only one partition---the [main partition](#main)---then all library units in
the program are assigned to that partition implicitly.

If, however, the program has more than one partition, then pragmas must be used: 

 * For every partition in the program except for the main partition, the configuration pragma
   `Partition` must be used to declare the name of the partition. 

 * Pragma `Assign_To_Partition` can be used to explicitly assign a library unit to a partition. 

The compilation units included in a partition are those of the explicitly assigned library
units, as well as other compilation units needed by those library units. 

The compilation units needed by a given compilation unit (the needed compilation units) are
determined as follows (unless specified otherwise via an implementation-defined pragma, or by
some other implementation-defined means):

 * A compilation unit is a needed compilation unit of itself;

 * If a compilation unit is among the needed compilation units, then so are any compilation
   units upon which it depends semantically;

 * If a library_unit_declaration is among the needed compilation units, then so is any
   corresponding library_unit_body;

 * If a compilation unit with stubs is among the needed compilation units, then so are any
   corresponding subunits;

 * If the (implicit) declaration of the limited view of a library package is among the needed
   compilation units, then so is the explicit declaration of the library package.






-----------------------------------------------------------------------------------------------
## Multiple Assignment

A library unit can, in general, be explicitly assigned to more than one partition, and,
similarly, the implicit assignment of a unit can result in it being assigned to multiple
partitions. 

How multiple assignment works depends on the category of the unit.


### Declared Pure

A declared pure unit will (in effect) be included as a separate copy in every partition it is
assigned to. 

A pure unit has no internal state. Therefore, for a pure unit, there is no semantic difference
between: 

 * the unit being separately included in each partition, and 

 * the unit being, in some sense, shared between them all. 


### Shared Passive

?????A shared passive library unit is not allowed (by any Ada compiler) to be assigned to multiple
partitions. 

A shared passive library unit has internal state that is guaranteed to be consistent among all
the partitions of the program. 

Any one shared passive unit must therefore be assigned to only one partition. 

The declaration of a library unit P1 is not accessible from within the declarative region of a
shared passive library unit P2, unless: 

 * the shared passive library unit P2 depends semantically on P1, or

 * P1 is assigned (explicitly or implicitly) to the same partition as P2, and P1 is *only*
   assigned to that partition. 


### Remote Types

A remote types library unit will (in effect) be included as a separate copy in every partition
it is assigned to. 

A remote types library unit has no internal state. Therefore, for a remote types library unit,
there is no semantic difference between: 

 * the unit being separately included in each partition, and 

 * the unit being, in some sense, shared between them all. 


### Remote Call Interface

For remote call interface (library unit), a separate copy of the unit's specification is
included in each partition in which there is a unit that depends on the RCI

However, an RCI is not allowed (by any Ada compiler) to be assigned to multiple partitions. 

.....


### Normal

A normal library unit has a separate copy included in every partition it is assigned to
(explicitly or implicitly). 







-----------------------------------------------------------------------------------------------
## 







-----------------------------------------------------------------------------------------------
## 










-----------------------------------------------------------------------------------------------
## Fixed Partitions {#fixed}

An [executable image](../pxcr/realizor.md#images) can contain a set of _fixed partitions_. 
These are the partitions that are pre-defined for the image. 

The [Run-Time Support Configuration Helper](../pxcr/realizor.md#rtsch) adds to the run-time
support configuration module an export named: 

    system.partitions.table
    
The `system.partitions.table` export is an array, the _fixed partition table_, giving 
information about all the fixed partitions in the image, indexed by fixed partition identifier. 



The following [module class definition](../pxcr/mcd.md) file .....

```xml
<.....>
   <include name="ada"/>
   <module-class name="system.partitions">
      <type name="system.partitions.table">
         (name: &at;ada.wide_string, main: &at;callable) &hash; ada.natural
      </type>
   </module-class>
</.....>
```

```
include ada;
system.partitions: begin module_class 
   system.partitions.table: type
      (name: @ada.wide_string, main: @subroutine) # ada.natural;
   end module_class;
```







The package `AdaOS.Partitions` contains the following declarations: 

```ada
   type Fixed_Partition_Count is range 0 .. ?????;
   
   subtype Fixed_Partition_Id is Fixed_Partition_Count range 1 .. Fixed_Partition_Count'Last;

   type Partition_Main_Procedure is access procedure;

   type Partition_Descriptor
   is 
      record
         Name: not null access Wide_String;
         Main: Partition_Main_Procedure;
      end record;

   Fixed_Partitions: array (Partition_Id) of Partition_Descriptor
   with
      Import,
      External_Name => "system.partitions.table";
```

The constant array `Fixed_Partitions` imports the fixed partition table for the image. 

The `Name` in the `Partition_Descriptor` is the name of the partition. 

.....



-----------------------------------------------------------------------------------------------
## Partition Objects {#obj}



????? Doesn't really need to be a system object?



The RTS represents each partition as a [system object](../objects/objects.md) of a type 
derived from the 

?????interface type `Program_Partition`, 

declared in the package `AdaOS.Execution`. 
Each such object is called an _partition object_. 

.......

The RTS maintains a registry of partition objects, called the _partition registry_. 








????? Identify them by id (1 to n) in an image, and build a mapping (name -> id) only when realising?








The package `AdaOS.Execution` contains the following declarations: 

```ada
   type Partition_Registry is synchronized interface and Objects.Object_Directory;

   function Registry return Partition_Registry'Class;
```

The interface type `Partition_Registry` is a [directory](../objects/containers.md#dir) whose 
members are the registered partitions. 

The function `Registry` returns the RTS partition registry.

The fixed partitions are all registered by the RTS, as a part of its 
[initialisation](../adaos/rts.md#init). 

It is possible for further partitions to be added to the registry, and for existing partitions 
to be removed from it or modified. It might be unusual for these manipulations to be done, in 
practice, but the facility is there. 

















-----------------------------------------------------------------------------------------------
## 




-----------------------------------------------------------------------------------------------
## Partition Modules {#mod}

Every partition can be, and generally is, made up of many [modules](../pxcr/modules.md). 


......



-----------------------------------------------------------------------------------------------
## Partition Initialisation Procedure {#aip}

When a partition is executed, by calling the function `New_Instance` and then calling `Create` on the 
returned instance (system object), _partition initialisation_ is executed in the instance. 

However, for every partition, there must be exactly one [module](#mod), called the _partition
module_ of the partition, which must contain an export named `init`, which must be a
parameterless subroutine. this export is called the _partition initialisation procedure_ of the
partition.

.....

.....

To perform partition initialisation, the 

partition initialisation procedure

calls the module initialisation procedure of each module in the partition, in the order they occur in 
the `Module_Init_Procs` list. 

.....
 


-----------------------------------------------------------------------------------------------
## 





-----------------------------------------------------------------------------------------------
## Configuring a Partition

.....


### Main Procedure

The [partition initialisation procedure](#aip) of a partition can be 
configured by .....: 

```xml



```





??????

```sh
chimg X
chasm A
asm-init P1 P2 P3 ...
```

where `X` is the name of the image, `A` is the name of the partition, and `P1`, `P2`, etc. is a 
list of export names. 

Each export must be the module initialisation procedure of one of the modules required by the 
partition. They must be in an order that is compatible with the dependencies between the 
modules; they will be called in the same order. 

?????An empty string value indicates no procedures, which is the default. 

The main procedure of a partition can be configured with these commands:

```sh
chimg X
chasm A
asm-main P
```
    
The value of `P` must be the name of an export. 

?????It may be the empty string value, to 
indicate that the partition has no main procedure. This is the default. 

If the partition is built by ECLAT, and the 

 [Run-Time Support Configuration Helper](../pxcr/realizor.md#rtsch) is used, 

this update item is set by the helper to be the [main subprogram of the partition](../eclat/building.md#main). 

????? or is this set for a program instead?

?????and anyway, this will be set automatically by the helper?

.....



-----------------------------------------------------------------------------------------------
## 





-----------------------------------------------------------------------------------------------
## Execution

An [partition object](#obj) has the procedure `Create_Instance` as a primitive operation. 

The `Create_Instance` procedure passes out, in the parameter `Instance`, (a remote access value
referencing) an object in `AdaOS.Execution.Executional_Instance'Class`, which is an object
representing a new [executional instance](../adaos/instances.md) whose partition (property)
references the partition object. 




????? The caller sets stuff?


AdaOS sets the instance's properties, 
then transitions it to Running mode. 



AdaOS calls the `create_task` subroutine of the [RTS](../rts/rts.md) in order to create the
environment task of the instance.

The [ambit](../security/security.md#amb) of the instance's compartment is used to specify the
ambit for the new task. .....



The environment task first performs [partition initialisation](#init), and then calls the
[main procedure](#main) of the partition, if there is one. 

.....
 
 

-----------------------------------------------------------------------------------------------
## 

















```
[ECLAT/Build/hello]
Library=${ECLAT/Base/Libraries}/hello
Module_File=hello,main.pxc
Definition=${ECLAT/Base/Definitions}/main.def
```

.....

Again, this example build configuration can be omitted, because, if the current directory when 
running `eclat` is named `hello`, it will be assumed by ECLAT by default. 

.....

For a normal program, named `Hello` let us say, the realisation would look like this:

```
[Realizor/hello]
Base/Module=${ECLAT/Base/RTS}/x64_mswin_tty.pxc
Base/Start=system_start
Auxiliary/Modules=${ECLAT/Base/RTS}/x64_mswin_tty_*.pxc
Plugins/Program_Part/Modules=*,main.pxc|${ECLAT/Base/Services}/*,main.pxc
Plugins/Program_Part/Init=init
```

This realisation is setting a [run time system](RTS.md) as the base module. In this case it 
is for the AMD-64 architecture (`x64`), with the Microsoft Windows operating system (`mswin`), 
for a text-only console (or 'teletype', `tty`) user interface. 

This realisation will also cause the Realizor to search the same directory as the configuration 
file for PXC module files whose name ends with `,main.pxc` which is the convention for modules 
that are normal 'main' partition modules. 

In fact, it is not necessary to explicitly put this realisation into the configuration, because 
if a realisation is not (explicitly) provided, the Realizor assumes the above configuration by 
default. In fact, the Realizor chooses a RTS module to match the architecture and operating 
system of the machine it is running on. 









.....



-----------------------------------------------------------------------------------------------
## 




-----------------------------------------------------------------------------------------------
## 




-----------------------------------------------------------------------------------------------
## Partition Definition Files



?????superseded now?



The assignment of library items to partitions, as well as, within each partition, the 
allocation of subprograms to segments, are submitted to ECLAT in the form of one or more 
_partition definition files_. 

There is conventionally partition definition file for each partition; the name of the file 
should be: 

    P,pd.txt
    
where `P` is the partition's name (but this is not required). 

The syntax of a partition definition file is as follows:

    partition P is
       {unit L ;}...
       {class C is
          {class C ;}... 
       end C ;}...
       {segment S is
          {class C ;}... 
       end S ;}...
       {group G is
          {segment S ;}... 
       end G ;}...
       {for G'Size use N ;}...
    end P ;

where:

 * `P` is the name of a partition, 
 
 * `L` is the fully qualified name of a library item, 
 
 * `C` is the name of a segmentation class, 
 
 * `S` is the name of a segment, 
 
 * `G` is the name of a segment group, and
 
 * `N` is a non-negative decimal literal integer. 
 
.....

.....








-----------------------------------------------------------------------------------------------
## Automatic Segmentation

The [Realizor](PXCR.md) can generate 

[partition profiling functionality](???)

which (among other things) enables the 

[profile interpreter program](???)

to compute a new---and improved---[segmentation plan](#segplans)

.....






-----------------------------------------------------------------------------------------------
## Examples


.....










-----------------------------------------------------------------------------------------------
## 




-----------------------------------------------------------------------------------------------
## 




-----------------------------------------------------------------------------------------------
## References

[1]: <http://ada-auth.org/standards/12rm/html/RM-10-2.html> "Ada Reference Manual, 10.2 Program 
     Execution"







