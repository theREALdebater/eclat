-----------------------------------------------------------------------------------------------
# Program Assemblies

A [program](programs.md) comprises one or more _assemblies_.

The program may be divided up into two or more assemblies, that can be executed separately---in
the future they will be capable of executing on different computers in a network---but which
nevertheless form part of a single coherent program: execution of one assembly would make no
sense without the concurrent execution of the other assemblies of the program. 

An assembly corresponds roughly to a traditional executable file of older operating systems
(including Microsoft Windows PE and Linux/ELF), but an [executable image](../pxcr/images.md)
generated by the [Realizor](../pxcr/realizor.md) can (and generally does) contain multiple
assemblies. 

For programs written in the Ada language, an assembly is, in general, an assembly of multiple
[partitions](../eclat/building.md#part). In many cases, in fact, an assembly will only have one
partition in it. Normally, each partition is built into a one module, and so an assembly will
be a collection of these partition modules. 

For programs written in the C language, one program (in the C sense) will comprise one program
(in the AdaOS sense) which has one assembly. 

??????The topic of **security** is dealt with in a [separate document](../security/security.md).

??????Assemblies are used as the basis for the [Annex E](remcomm.md#dsa) support of ECLAT. 



-----------------------------------------------------------------------------------------------
## Assembly Names

An assembly is identified, within its program, by an _assembly name_. 

An assembly name is usually a simple name, .....

By default, the name of the [assembly module](#mod) is the name of the program, with a dot
appended, and then the name of the assembly appended to that. 
 
The name of the [main assembly](#main) is always `main`. 

For example, the name of the main assembly of a program named `ACME.GISF.Electroanalysis` would
be: 

    ACME.GISF.Electroanalysis.main



-----------------------------------------------------------------------------------------------
## Fixed Assemblies {#fixed}

An [executable image](../pxcr/realizor.md#images) can contain a set of _fixed assemblies_. 
These are the assemblies that are pre-defined for the image. 

The [Run-Time Support Configuration Helper](../pxcr/realizor.md#rtsch) adds to the run-time
support configuration module an export named: 

    system.assemblies.table
    
The `system.assemblies.table` export is an array, the _fixed assembly table_, giving 
information about all the fixed assemblies in the image, indexed by fixed assembly identifier. 



The following [module class definition](../pxcr/mcd.md) file .....

```xml
<.....>
   <include name="ada"/>
   <module-class name="system.assemblies">
      <type name="system.assemblies.table">
         (name: &at;ada.wide_string, main: &at;callable) &hash; ada.natural
      </type>
   </module-class>
</.....>
```

```
include ada;
system.assemblies: begin module_class 
   system.assemblies.table: type
      (name: @ada.wide_string, main: @subroutine) # ada.natural;
   end module_class;
```







The package `AdaOS.Assemblies` contains the following declarations: 

```ada
   type Fixed_Assembly_Count is range 0 .. ?????;
   
   subtype Fixed_Assembly_Id is Fixed_Assembly_Count range 1 .. Fixed_Assembly_Count'Last;

   type Assembly_Main_Procedure is access procedure;

   type Assembly_Descriptor
   is 
      record
         Name: not null access Wide_String;
         Main: Assembly_Main_Procedure;
      end record;

   Fixed_Assemblies: array (Assembly_Id) of Assembly_Descriptor
   with
      Import,
      External_Name => "system.assemblies.table";
```

The constant array `Fixed_Assemblies` imports the fixed assembly table for the image. 

The `Name` in the `Assembly_Descriptor` is the name of the assembly. 

.....



-----------------------------------------------------------------------------------------------
## Assembly Objects {#obj}



????? Doesn't really need to be a system object?



The RTS represents each assembly as a [system object](../objects/objects.md) of a type 
derived from the 

?????interface type `Program_Assembly`, 

declared in the package `AdaOS.Execution`. 
Each such object is called an _assembly object_. 

.......

The RTS maintains a registry of assembly objects, called the _assembly registry_. 








????? Identify them by id (1 to n) in an image, and build a mapping (name -> id) only when realising?








The package `AdaOS.Execution` contains the following declarations: 

```ada
   type Assembly_Registry is synchronized interface and Objects.Object_Directory;

   function Registry return Assembly_Registry'Class;
```

The interface type `Assembly_Registry` is a [directory](../objects/containers.md#dir) whose 
members are the registered assemblies. 

The function `Registry` returns the RTS assembly registry.

The fixed assemblies are all registered by the RTS, as a part of its 
[initialisation](rts.md#init). 

It is possible for further assemblies to be added to the registry, and for existing assemblies 
to be removed from it or modified. It might be unusual for these manipulations to be done, in 
practice, but the facility is there. 



-----------------------------------------------------------------------------------------------
## 




-----------------------------------------------------------------------------------------------
## Assembly Modules {#mod}

Every assembly can be, and generally is, made up of many [modules](../pxcr/modules.md). 


......



-----------------------------------------------------------------------------------------------
## Assembly Initialisation Procedure {#aip}

When an assembly is executed, by calling the function `New_Instance` and then calling `Create` on the 
returned instance (system object), _assembly initialisation_ is executed in the instance. 

However, for every assembly, there must be exactly one [module](#mod), called the _assembly
module_ of the assembly, which must contain an export named `init`, which must be a
parameterless subroutine. this export is called the _assembly initialisation procedure_ of the
assembly.

.....

.....

To perform assembly initialisation, the 

assembly initialisation procedure

calls the module initialisation procedure of each module in the assembly, in the order they occur in 
the `Module_Init_Procs` list. 

.....
 


-----------------------------------------------------------------------------------------------
## 




-----------------------------------------------------------------------------------------------
## Main Assembly and Main Procedure {#main}

There is always exactly one assembly in a program that is the _main assembly_. 

The main assembly, and only the main assembly, always contains one export, which must be a
parameterless subroutine named `main`, which is the _main procedure_ of the program. 

.....



-----------------------------------------------------------------------------------------------
## Configuring a Assembly

.....


### Main Procedure

The [assembly initialisation procedure](#aip) of an assembly can be 
configured by .....: 

```xml



```





??????

```sh
chimg X
chasm A
asm-init P1 P2 P3 ...
```

where `X` is the name of the image, `A` is the name of the assembly, and `P1`, `P2`, etc. is a 
list of export names. 

Each export must be the module initialisation procedure of one of the modules required by the 
assembly. They must be in an order that is compatible with the dependencies between the 
modules; they will be called in the same order. 

?????An empty string value indicates no procedures, which is the default. 

The main procedure of an assembly can be configured with these commands:

```sh
chimg X
chasm A
asm-main P
```
    
The value of `P` must be the name of an export. 

?????It may be the empty string value, to 
indicate that the assembly has no main procedure. This is the default. 

If the assembly is built by ECLAT, and the 

 [Run-Time Support Configuration Helper](../pxcr/realizor.md#rtsch) is used, 

this update item is set by the helper to be the [main subprogram of the 
assembly](../eclat/building.md#main). 

????? or is this set for a program instead?

?????and anyway, this will be set automatically by the helper?

.....



-----------------------------------------------------------------------------------------------
## 





-----------------------------------------------------------------------------------------------
## Execution

An [assembly object](#obj) has the procedure `Create_Instance` as a primitive operation. 

The `Create_Instance` procedure passes out, in the parameter `Instance`, (a remote access value
referencing) an object in `AdaOS.Execution.Executional_Instance'Class`, which is an object
representing a new [executional instance](instances.md) whose assembly (property) references
the assembly object. 




????? The caller sets stuff?


AdaOS sets the instance's properties, 
then transitions it to Running mode. 



AdaOS calls the `create_task` subroutine of the [RTS](../rts/rts.md) in order to create the
environment task of the instance.

The [ambit](../security/security.md#amb) of the instance's compartment is used to specify the
ambit for the new task. .....



The environment task first performs [assembly initialisation](#init), and then calls the [main
procedure](#main) of the assembly, if there is one. 

.....
 
 

-----------------------------------------------------------------------------------------------
## Initial Assembly {#initasm}

A normal RTS requires that an [executional image](../pxcr/realizor.md#images) must have exactly 
one assembly that is the _initial assembly_ of the image. 

Once the RTS has completed its own [initialisation](rts.md#init), it executes the initial 
assembly, and when the initial assembly completes execution, the RTS initiates [system shutdown](rts.md#shutdown). 

The [run time system configuration module](#helper) contains .....

The initial assembly is executed in the [top compartment](compart.md#top) and is, initially,
the only assembly executing in that compartment (and the top compartment is initially the only
existing compartment). 





?????

The `.name.` export is a value of type `Wide_String` and contains the name of the initial 
assembly of the image. It is termed the _explicit initial assembly name_. This value may be a 
null string, which indicates that there is no explicit initial assembly name. 

The `.vars.` export contains a list of wide string key-value pairs. These will be used to add 
to, or change, the environment variables passed into the initial assembly when the RTS executes 
it. 

The Ada package `AdaOS.Assemblies` contains the following declarations: 

```ada
   type Initial_Assembly_Descriptor
   is
      record
         Id:               Assembly_Id;
         Compartment_Id:   Compartment_Number;
      end record;

   for Initial_Assembly_Descriptor
   use
      record
         Id                at 0 range 0 .. Assembly_Id'Size - 1;
         Compartment_Id    at 0 range Assembly_Id'Size - 1 .. Assembly_Id'Size + Compartment_Number'Size - 1;
      end record;

   Initial_Assembly: Initial_Assembly_Descriptor
   with
      Import,
      External_Name => "system.config.initial_assembly";
```

The C header file `adaos/assemblies.h` contains the following declarations: 

```c

typedef struct {
   assembly_id_t     id;
   compartment_id_t  compartment_id;
} initial_assembly_t;
```









If only one assembly has been registered, that assembly is the _default initial assembly_. 

The _initial assembly_ of the image is: 

 * if the explicit initial assembly name is not null, the registered assembly whose name 
   matches it, if any does match it; 
   
 * otherwise, the default initial assembly if there is one. 
 
Otherwise, there is no initial assembly. 

If there is no initial assembly, the RTS fails (it outputs an error message if the target is a 
hosted platform). 

The initial assembly is automatically executed by the RTS, just after it has performed its own 
[initialisation](rts.md#init). Any other assemblies will only be executed by running code doing 
so. 

The package `AdaOS.Execution` contains the following declaration:

```ada
   function Top_Instance return access Executional_Instance'Class;
```

The function `Top_Instance` returns (an access value that references) the executional instance 
created by the RTS to run the initial assembly. 

.....



-----------------------------------------------------------------------------------------------
## Configuring the Initial Assembly

.....



????? Change to XML.





### Name

The name of the initial assembly is the value of the following configuration item:

    rts/images(X)/initial_assembly/name
    
where `X` is the name of the executable image. 

The default value of this item is `adaos.tethys`, so, by default, if an assembly named 
`adaos.tethys` is registered, it will be executed automatically when the image is run. See 
[Tethys](../services/tethys.md) for more about the Tethys program controller. 








????? This is configured for the top compartment.



### Program Arguments

In order to set the program arguments that will be made available to the initial assembly when 
it is executed by the RTS, the following state update item can be set: 

    rts/images(X)/initial_assembly/args
    
where `X` is the name of the executable image. 

.....

```ada
   ......
```

The default is an empty array. 


### Environment Variables

On a hosted platform, the default set of environment variables is the set of environment 
variables inherited from the underlying operating system. 

On the AdaOS platform, the default set of environment variables is none at all. 

In order to add to or change an environment variable that will be made available to the 
initial assembly when it is executed by the RTS, the following state update item can be set: 

    rts/images(X)/initial_assembly/vars(V)

where `X` is the name of the executable image and `V` is the name of the variable. 

.....

```ada
   ......
```



.....




-----------------------------------------------------------------------------------------------
## 

















```
[ECLAT/Build/hello]
Library=${ECLAT/Base/Libraries}/hello
Module_File=hello,main.pxc
Definition=${ECLAT/Base/Definitions}/main.def
```

.....

Again, this example build configuration can be omitted, because, if the current directory when 
running `eclat` is named `hello`, it will be assumed by ECLAT by default. 

.....

For a normal program, named `Hello` let us say, the realisation would look like this:

```
[Realizor/hello]
Base/Module=${ECLAT/Base/RTS}/x64_mswin_tty.pxc
Base/Start=system_start
Auxiliary/Modules=${ECLAT/Base/RTS}/x64_mswin_tty_*.pxc
Plugins/Program_Part/Modules=*,main.pxc|${ECLAT/Base/Services}/*,main.pxc
Plugins/Program_Part/Init=init
```

This realisation is setting a [run time system](RTS.md) as the base module. In this case it 
is for the AMD-64 architecture (`x64`), with the Microsoft Windows operating system (`mswin`), 
for a text-only console (or 'teletype', `tty`) user interface. 

This realisation will also cause the Realizor to search the same directory as the configuration 
file for PXC module files whose name ends with `,main.pxc` which is the convention for modules 
that are normal 'main' assembly modules. 

In fact, it is not necessary to explicitly put this realisation into the configuration, because 
if a realisation is not (explicitly) provided, the Realizor assumes the above configuration by 
default. In fact, the Realizor chooses a RTS module to match the architecture and operating 
system of the machine it is running on. 









.....



-----------------------------------------------------------------------------------------------
## 




-----------------------------------------------------------------------------------------------
## 




-----------------------------------------------------------------------------------------------
## Assembly Definition Files



?????superseded now?



The assignment of library items to assemblies, as well as, within each assembly, the 
allocation of subprograms to segments, are submitted to ECLAT in the form of one or more 
_assembly definition files_. 

There is conventionally assembly definition file for each assembly; the name of the file 
should be: 

    P,pd.txt
    
where `P` is the assembly's name (but this is not required). 

The syntax of an assembly definition file is as follows:

    assembly P is
       {unit L ;}...
       {class C is
          {class C ;}... 
       end C ;}...
       {segment S is
          {class C ;}... 
       end S ;}...
       {group G is
          {segment S ;}... 
       end G ;}...
       {for G'Size use N ;}...
    end P ;

where:

 * `P` is the name of an assembly, 
 
 * `L` is the fully qualified name of a library item, 
 
 * `C` is the name of a segmentation class, 
 
 * `S` is the name of a segment, 
 
 * `G` is the name of a segment group, and
 
 * `N` is a non-negative decimal literal integer. 
 
.....

.....








-----------------------------------------------------------------------------------------------
## Automatic Segmentation

The [Realizor](PXCR.md) can generate 

[assembly profiling functionality](???)

which (among other things) enables the 

[profile interpreter program](???)

to compute a new---and improved---[segmentation plan](#segplans)

.....






-----------------------------------------------------------------------------------------------
## 




-----------------------------------------------------------------------------------------------
## 




-----------------------------------------------------------------------------------------------
## 




-----------------------------------------------------------------------------------------------
## References

[1]: <http://ada-auth.org/standards/12rm/html/RM-10-2.html> "Ada Reference Manual, 10.2 Program 
     Execution"







