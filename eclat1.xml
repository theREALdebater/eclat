<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//Norman Walsh//DTD DocBk XML V3.1.4//EN"
                      "http://nwalsh.com/docbook/xml/3.1.4/db3xml.dtd">

<chapter>

<title>Guide to Use</title>

<p>This chapter describes all aspects of invoking and using the Ada
compiler ...</p>



<section>

<title>Overview</title>

<para>The compiler is a Prolog program, which must be executed using the
&adaos; <application>Native Prolog Interpreter</application>, which is the
native &adaos; executable program <filename>prolog</filename>. The Ada
compiler that is interpreted by Prolog in the file
<filename>adacom</filename>. Both these files are supplied as part of the
<systemitem class="distribution">AdaOS Native Software
Development</systemitem> distribution.</para>

</para>

<para>The main functions the Ada compiler program performs are:</para>

<itemizedlist>

<listitem>translation of Ada source files into intermediate code (library
unit) files;</listitem>

<listitem>translation of library unit files into executable or dynamically
linked library files;</listitem>

<listitem>the management of a library of Ada source files, and their
corresponding library unit and other generated files, to automatically
determine the minimum set of those files which need to be processed in
order to fully update the library;</listitem>

<listitem>optionally, the production of assembly listings, the production
of COFF object files, and the production of debugging
information.</listitem>

</itemizedlist>

<para>Note that all these functions are integrated into one program
(<filename>adacom</filename>), whereas with most compiled program
development products these functions would be performed by separate
programs. The reason for this integration is to allow the most efficient
(i.e. fastest) rebuilding of a library (library unit files can be kept in
memory, rather than having to be written out to disk and then read back in
again by another program).</para>

</section>




<section>

<title>Installation</title>

<para>The compiler program (<filename>adacom</filename>) is installed by
the product set-up program in the product base directory (named
"ThoughtWing Ada" by default). See the Installation and Set-up Guide, also
supplied with this product, for more information.</para>

















A.Quick Guide
It is not usually necessary to know the detailed information in this guide in order to use the compiler. The quick guide presented in this section will often be sufficient.
To compile a set of Ada source files into an executable program, called "X.EXE" say, follow these steps:
1.create a new directory (named "D", let us say), and copy the contents of the directory called "Standard Library", installed by the compiler's set-up program into the product base directory (named "ThoughtWing Ada" by default);
2.create all the necessary Ada source files in this directory, or, if they already exist, move (or copy) them into the directory, or create links (shortcuts) to the source files in the directory;
3.execute the command "TWADACOM /EXE=X" (this can be done on a DOS command line, or by choosing "Run" from the Windows Start menu);
4.if all is well, the executable program "X.EXE" will be created, in directory "D".
Ensure that all the Ada source files have the filename extension "ADA".
Warnings, errors, and other messages are displayed in a console window.
If an error prevents the creation of the executable program, one or more of the Ada source files must be edited to eliminate the bug. Having done this, all that is necessary is to re-issue the command "TWADACOM" (no arguments are necessary after the first execution of this command). If there are no more errors, the executable program will be created.
The executable program "X.EXE" can be run like any other program (e.g. by double-clicking on its icon). Execution of this program comprises the execution of a library unit called "MAIN", which must be a parameterless procedure.
To debug the program, issue the command "TWADACOM /DEBUG=ON". This will regenerate the executable program "X.EXE" with debugging functionality, and another file, "X.DBG" in this case, will also be generated (containing sundry debugging information). Now run the command "TWDEBUG X".
I.File Overview
The compiler deals with the following types of files:
Ada source files [.ADA];
build control files [.BC];
library unit files [.LU];
executable files [.EXE];
DLL (dynamically linked library) files [.DLL];
debugging information files [.DBG];
object files [.OBJ];
library files (statically linked) [.LIB];
source listing files [.LST];
assembly listing files [.ASM];
symbol map files [.MAP].
The usual filename extension of each type of file is given in square brackets.
The last five types of file listed above are rather esoteric. Most users of the compiler will never deal with any of these types of file. (Sometimes it is convenient to use source listing files in conjunction with the debugger.)
A.Text Files
Ada source files and build control files are both text files which the compiler reads. The following rules apply to all the text files which the compiler reads:
the character set is assumed to be ISO 8859-1 (a superset of ASCII), with one 8-bit byte representing each character;
each line is terminated by a CR character, or a LF character unless it is preceded by a CR, or a VT unless it is preceded by a CR or LF, or a FF unless it is preceded by a CR, LF, or VT, or a SUB character or the end of the file unless this is preceded by a CR, LF, VT, or FF;
the file is terminated by (i.e. reading stops at the point of) the first SUB character encountered, or the end of the file if no SUB is encountered first;
line numbering starts at one and increments at every line termination (page breaks and vertical tabulations are ignored);
control characters other than HT, LF, VT, FF, CR, SUB, SPACE, and NBSP are illegal, and cause a fatal error;
NBSP is treated as SPACE (but its use is deprecated).
Build control files, source listing files, assembly listing files, and map files are all text files which the compilers writes out. When generating a text file, the following rules always apply:
the character set used is ISO 8859-1, with one 8-bit byte representing each character;
each line is terminated by a CR followed by a LF;
the file is terminated with a final SUB.
A.Ada Source Files
Ada source files are text files (see section 2.1) which contain Ada source text, as defined in the Ada Reference Manual.
The ThoughtWing compiler allows any number of library units to be declared in one file (unlike some other Ada compilers). However, if there are two or more library units declared in one file, there is the possibility that the compilation will fail simply because a consistent order of compilation cannot be found. This problem will occur if a library unit depends, directly or indirectly, on another library unit declared later on in the same source file. For this reason, it is recommended that, for normal purposes, only one library unit is declared in a source file.
The ThoughtWing compiler also allows an Ada source file to have no library units declared in it at all. It may occasionally be convenient to declare one or more library-level pragmas in a separate source file (with no library units declared in it). It may also occasionally be convenient to include in a library a source file which contains only comments (where the intention is to insert pragmas or library unit declarations into the file at a later date). If a source file contains no text at all (other than whitespace), a warning is issued.
A.Build Control Files
Build control files are text files (see section 2.1) which contain all the information the compiler needs to keep to enable it to rebuild a library (and to do so efficiently). For more information, see section 4.2.
When the compiler is executed, it first reads in a build control file (if there is no build control file, the compiler asks for the relevant information from the user); when the compiler has completed all its other work, it writes out the build control file again (complete with all necessary modifications).
A.Library Unit Files
Library unit files contain an intermediate encoded form of the library units and pragmas declared in the Ada source files which make up the library. Compilation of Ada source files results in the generation of library unit files, in the first instance.
There is one library unit file for each library unit declared (regardless of whether the Ada source file it was declared in contained other library unit declarations or not).
The library unit file contains all the same information as its corresponding source text, except for comments and whitespace. Different forms in the source text which have the same meaning are not distinguished. Also, where the omission of a segment of source text would not change the meaning of the program, the two (or more) possible forms are not distinguished.
However, library unit files are binary files (i.e. not text files). The format of library unit files is defined by ThoughtWing. A copy of the specification of the format of library unit files is available from ThoughtWing at the cost of media, packing, and postage only.
Generally, the information stored in library unit files is architecture-independent. Library unit files are designed to be maximally downwards compatible. Consequently, library unit files can be used interchangeably between all ThoughtWing Ada products.
A.Executable Files

A.Editor Context Files
An editor context file holds information about the (usually Ada source) text files most recently opened in the editor program ???. The information includes which part of each file was being displayed, where the caret was positioned, the locations of markers, and so on. See ??? for more details about these files.
The Ada compiler has the ability to open and update one or more editor context files. If (and only if) warnings (or an error) are detected, markers are set in the appropriate locations in the appropriate files, so that these locations can be easily reached when the editor is next started up. Each marker is named according to the kind of warning (or error) it refers to.
By default, the compiler does not open or update editor context files. It will only open an editor context file if told to do so by means of the /EC flag (see 'Flags' below).
I.Paths and Pathnames
A pathname specifies the name of a file. The syntax of a pathname is given below.
[drive-letter:][\]{directory-name\}[basename[.extension]]
If only a drive is specified (a drive letter followed by a : colon), the form is called a drive. If the basename (and extension) is omitted (and the form therefore ends with a \ backslash), the form is called a path, otherwise it is called a pathname.
…

1.Wildcards
…

I.The Build Process
The compiler has the ability to do a 'minimal rebuild'. It can automatically determine the minimum set of Ada source files, their corresponding library unit files, and other generated files, which need to be processed in order to fully update the library. A minimal rebuild is done by default, but it is optional: a flag can be used (the '/ALL' flag) to force the compiler to recompile the entire library. 
In order to manage the rebuilding process, the compiler uses a 'build control' file (see 4.2).

A.Rules of Minimal Rebuild 
A minimal rebuild obeys the following rules:
if any of the library unit files of the library units declared in a Ada source file are out of date or missing, the Ada source file is recompiled;
if any of the generated executable, DLL, or object files is out of date (its modification time is before or the same as the modification time of any of the library unit files involved in its generation) or missing, it is regenerated.
A full rebuild, on the other hands, recompiles all the Ada source files in the library, and regenerates all the generated executable, DLL, and object files.
A.Build Control Files
A build control file contains all the information required to manage the rebuilding (minimal or not) of an Ada library. Each build control file contains the following information:
a list of pathnames for Ada source files;
a list of the library units which are declared in the above Ada source files;
for each of the above library units, the pathname of the library unit file the library unit is compiled into, and also a list of all the other library units which the library unit is dependent on, and a list of all the library units which depend on it;
the library-wide settings of the compiler for this library.
…
Build control files are text files; this makes it possible to edit a build control file (using any text editor). It should not normally be necessary to do this, but sometimes it may be necessary or convenient. Also, automated tools can be readily programmed to construct or modify build control files (for example, the project manager program supplied with ThoughtWing Ada products).
The format for build control files is quite simple. Each line may begin with either an '/' oblique or a letter. If the line starts with an oblique, the whole line takes the form of a single flag, as described below, for the compiler.
A flag in the build control file has exactly the same effect as if it had been submitted to the compiler on the command line, except that if the same flag (with whatever parameters) is actually submitted on the command line, the command-line flag takes precedence (and when the build control file is rewritten by the compiler, the original flag and parameters are replaced by the new ones). 
If the line begins with a letter, the letter is followed by an '=' equals sign, and then a parameter. The meaning of the line depends on the letter as follows:
(S) the parameter is the pathname of an Ada source file which is a part of the build;
(U) the parameter is the name (an identifier) of a library unit specification (or combined specification and body) which is declared in the Ada source file most recently mentioned in this build control file;
(B) the parameter is the full name of a library unit body (not a combined specification and body) which is declared in the most recently mentioned Ada source file;
(D) the parameter is the full name of a library unit (specification or combined specification and body) upon which the library unit most recently mentioned by a U or a B directive depends (dependency as defined by the Ada language);
If no units are named (by a U or B directive) for a Ada source file, the compiler always compiles this Ada source file, on the assumption that the library units it contains are unknown. Such Ada source files are compiled before any others.
If no dependencies are named (by a D directive) for a library unit, the corresponding library unit is opened, and its dependencies read (from the file header). In order to stop this happening for a library which is genuinely independent (very rare), the compiler always writes a "D=STANDARD" directive for the unit. Otherwise, mentioning the Standard package is unnecessary (it is always assumed).
Whether the letter is upper or lower case does not matter. If a pathname is relative, it will be relative to the directory which is current when the compiler is executed. The compiler always writes absolute pathnames (avoiding the danger of the current directory being incorrect).


I.Command-Line Arguments
Command-line arguments are strings which can be specified to be passed to a program when it is executed. Some of these arguments may be a special form, called flags (and there is a special form of argument called an argument file). The program can use these arguments and flags to determine or modify its actions. Most operating systems provide a mechanism for passing these strings into the program, but the mechanisms differ slightly, and so do various conventions.
A flag is usually differentiated from an ordinary argument by starting with a special character. This is usually a '-' hyphen (typical of UNIX and similar operating systems), or a '/' solidus (typical of VAX, MS-DOS and similar operating systems). ThoughtWing programs supplied for execution under Microsoft Windows (whose inheritance is more from MS-DOS) conventionally use the solidus (and the documentation reflects this); however a hyphen can always be used instead.
If an argument begins with an '@' at-the-cost-of sign, the remainder of the argument specifies the pathname of an argument file. This is a text file which contains arguments for the compiler (one per line), and is an alternative way of specifying arguments.
Where a flag is positioned in sequence relative to other flags and arguments is never of significance, with one exception: a flag which consists of simply a solidus (or a hyphen) on its own causes all subsequent arguments to be interpreted as ordinary arguments (not flags) regardless of which character they start with.
This section describes the command-line arguments and flags which are recognised by the compiler (specifically, the TWADACOM.EXE program).
With some programs, the case of a flag (whether it is specified in upper or lower case) matters; i.e. the flag "-a" might be quite different to flag "-A". With ThoughtWing programs, this is never so: upper and lower case are never distinguished for the names of flags. The same is true, for all ThoughtWing programs, of flag parameters which are identifiers (not paths or pathnames). However, whether the case matters of a flag parameter, or of any other argument, which is a path or pathname, depends upon the underlying operating system. Under current versions of Windows, case is ignored when searching for a file's or directory's name (although case is preserved when creating a name).
A.Argument Files
If a command-line argument begins with an '@' at-the-cost-of sign, the remainder of the argument specifies the pathname of an argument file.
Two or more argument files can be specified, in which case each is read and interpreted in turn. Wildcard characters are allowed in the pathname following the @ sign, in which case each matching file is interpreted as an argument file. If no extension is specified, an extension of "TXT" is assumed (unless the pathname ends with a '.' dot, in which case a blank extension is assumed).
An argument file is a text file (see 2.1) which contains arguments for the compiler. There is always one argument on each line in the file, regardless of any space or tab characters in the argument. No quotation characters are required or allowed surrounding an argument, and there is no variable substitution facility (using the '%' percent character) available. The % sign is not interpreted in any special way. Also, argument files cannot be specified (i.e. the nesting of argument files is not allowed). The @ sign is not interpreted in any special way.
Argument files are an alternative way of specifying arguments to the compiler. They can be useful for a variety of purposes, for example:
If there are too many arguments to fit (conveniently) on the command line itself;
If there is a group of arguments (flags or other) which are frequently used together;
If the arguments passed to the compiler are software generated (and thus the number of arguments could be very large);
For keeping an exact record of which arguments were passed to the compiler;
If you simply prefer using the facilities of a text editor for editing the arguments (but you do not wish to use a batch file).
If other arguments are specified on the command line, these are interpreted in addition to the arguments in the argument file or files.
A.Ordinary Arguments
If a command-line argument is specified which is not a flag or an argument file then, if it is a pathname (see chapter 3), it is taken to be the pathname of a file which is to be involved in the build. How the file is involved in the build depends on its type. This is determined by the file's extension, in combination with the filename extension settings currently in force (see ???). The compiler accepts wildcard characters, in which case it acts on each matching file (for a pathname) or directory (for a path) as described below.
1.Paths
If a path (rather than a pathname) is specified, the compiler includes all the Ada source files in the specified directory in the build; the compiler assumes that all files within the directory which have the current extension for Ada source files are Ada source files. Thus, specifying a path "p\" has the same effect as specifying the pathname "p\*.a", where a is the current extension for Ada source files. If a pathname (rather than a path) is specified, the compiler proceeds as described below.
1.Pathnames
If no extension is specified, then the current extension for Ada source files is assumed (default "ADA"); if, however, the pathname given ends with a '.' dot, a blank extension is assumed; in either case, the file is assumed to be an Ada source file. If an extension is specified which does not match one of the current extension settings, the file is assumed to be an Ada source file. If an extension is specified which does match one of the current extension settings, the file is assumed to be of the type implied by the extension. The way in which files of different types are included in the build is described below.
1.Interpretation of File Types
a)Ada Source Files
Any Ada source file specifically included in the build is compiled (no test is made to 
A.Flags
This section describes the syntax and function of all the flags which can passed to the compiler.
The syntax of all the flags follows the following basic pattern: solidus (or hyphen); name of the flag; optionally, an '=' equals sign (or a ':' colon) followed by a flag parameter. Not all flags take a flag parameter. Of those which do, the syntax and meaning of the flag parameter depends on the flag.
1.Information
The information flags affect the information output by the compiler (to its console window) during the compilation process, and also whether the compiler operates in interactive mode or not.
a)/Q (Quiet Mode)
When the quiet mode flag is specified, the compiler produces no output except errors and warnings. Hence, if the compilation succeeds, the compiler will output nothing at all. This flag switches off interactive mode. In quiet mode, the compiler does not interact with the user, even if it requires extra information. If the compiler does require extra information it simply assumes the appropriate default value.
This flag supersedes the interactive mode and verbose mode flags.
a)/i (Interactive Mode)
When the interactive mode flag is specified, the compiler outputs a copyright notice, and the name of each file it is either reading or writing, in addition to any errors or warnings. Also, the compiler may interact with the user: if the compiler requires extra information, it asks the user for it (by outputting a prompt, and then waiting for the user to type in the appropriate response). The compiler does not interact if its input or output is redirected from/to a file.
This flag supersedes the quiet mode and verbose mode flags.
Interactive mode is the default mode (rather than quiet or verbose).
a)/V (Verbose Mode)
When the verbose mode flag is specified, the compiler outputs information as for the interactive mode, but also outputs detailed information about the compilation process (such as the names of library units being processed). The compiler may also interact with the user, as in interactive mode.
In verbose mode, there is the likelihood of a stream of text pouring up the console window (too fast to read). It may, therefore, be useful to redirect the compiler's output, in order to capture the output in a file. Of course, if you do this, the compiler will be prevented from interacting, so it you should be careful to ensure the compiler is given all the information it needs as command-line arguments.
This flag supersedes the quiet mode and interactive mode flags.
a)/WX (Warning Exclusion)
Every warning which the compiler outputs is preceded by an identifying number. It may sometimes be convenient to prevent the display of one or several (or even all) warning messages (perhaps because they are swamping other, more important, messages).
The warning exclusion flag is used to tell the compiler not to output particular warning messages. If no flag parameter is specified with this flag, all warnings are excluded. If a null flag parameter is specified (i.e. an '=' or ':' followed by nothing), no warnings are excluded (the default state). Otherwise, the flag parameter must consist of one or more positive decimal integers, separated by ';' semicolons, each of which designates a warning message to be excluded.
1.Build Control
These flags affect the overall way the compiler rebuilds the library.
a)/ALL (Compile All Files)
If this flag is specified, all the Ada source files in all the current build control files are recompiled (regardless of their modification dates and times). Consequently, the compiler does not have to (and so does not) check the modification dates and times of any of the library unit files specified in any of the current build control files.
Note that the fact that all library unit files are regenerated causes all other generated files in the build (i.e. executable files, DLL files, output object files, source listing files, assembly listing files, and map files) to be regenerated also.
This option is useful if:
the modification dates and times of any of the Ada source or library unit files specified in any of the current build control files are (or may be) inconsistent with one another (for example, if the system date or time has been changed); and/or
one or more of the library's generated files has or may have been deleted (after pollarding for example) or become corrupted; and/or
the compiler is suspected of failing to manage the rebuild process correctly.
In the last case, you should contact ThoughtWing to report the suspected problem, using the procedure set out in 7.2.
1.Link-Specific
The traditional 'linker' was a separate program which performed the final stage in the compilation process: that of bringing together a number of object files (as output by the prior compilation programs) and statically linked libraries (files each of which contained a collection of compilation objects), and 'fixing up' the links (calls, jumps, and variable references) between them. The linker's output was an executable file.
The ThoughtWing Ada compiler (in common with most other Ada compilers) effectively has a built-in 'linker'. Consequently, the compiler accepts a number of flags to control things which would traditionally have been among the duties of a linker. These flags are grouped together in this section.
a)/STK (Stack Size)
The  stack size flag specifies the initial size of the executable program's stack. ###what about multiple executables?
a)/VER (Version)
Windows allows two version numbers (major and minor, both 16-bit) to be put into the header of an executable file. The same is true of dynamically linked library files (DLLs). Utility programs can then display these version numbers, for informational purposes, and the program itself can query its own version numbers (to display to the user, perhaps). The version flag specifies the version numbers to be used.
Each number must be specified in decimal, with no internal or external spacing or punctuation. Each must be between 0 and 65535 in value (inclusive). If one number is specified, it is taken to be the major version number, and the minor version number defaults to zero. Both numbers can be specified separated by a comma or a '.' dot, major first, and then minor.
If version numbers are not specified, they both default to zero.
If more than one executable or DLL file is being generated, the same version numbers are put into all of them. If a generated executable or DLL file does not need to be regenerated, but a different version number has been specified, the new version number is simply written straight into the file (the file is not — and does not need to be — regenerated).
a)/ARCH (Architecture and Execution Environment)
The architecture and execution environment flag designates what hardware output machine code is going to be running on, and what operating system ('execution environment' is more or less just a fancy name for an operating system) it's going to be running under.
The current options for architecture are set out in the following table.

Id	Description	
i3	Intel 80386 and compatible processors	
i4	Intel 80486 and compatible processors	
i5	Intel Pentium and compatible processors	
i5MMX	Intel Pentium II and compatible processors	
i6	Intel Pentium Pro and compatible processors	

The default is "i3". If no architecture and execution environment flag is specified, or if the compiler is not invoked in an interactive mode, the default is used. If the flag is specified, but without any flag parameter (and the compiler is in an interactive mode), the compiler prompts the user for the identifier of an architecture. If the response is null, the default is used; otherwise the response must have the same syntax as a flag parameter for this flag (and is interpreted in the same way).
Be careful: if "i4" is specified, the compiler will (almost certainly) generate some machine instructions which an 80386 or compatible processor will not be able to execute (resulting in the program crashing). Similarly, with "i5", an 80486 (not to mention an 80386) is likely to crash; with "i5MMX", a non-MMX processor will certainly crash; with "i6", any processor other than a Pentium Pro or Cyrix 6x86 could well crash. So, for a program which is going to be generally distributed, either use "i3" or make sure that a version compiled with "i3" is also available.
For example, if you have written a hot graphics program for use only on MMX-endowed platforms, the flag
/arch=i5mmx
will cause the compiler to produce machine code which takes full advantage of the Multi-Media eXtensions to be found on modern Intel-type processors.
An execution environment (operating system) can optionally be specified after the architecture (separated by a comma). At the moment, the only operating system option is for Windows 95, 98, or NT. The corresponding identifier is "WIN32" (because the aforementioned operating systems all primarily provide an application program interface — or 'API' — called 'Win32').
So in the previous example the flag
/arch=i5mmx,win32
could have been used, with the same effect.
In future, ThoughtWing Ada compilers will support a much greater variety of architectures and execution environments, both as host (what the compiler can run on) and target (what the programs it creates can run on). Generally, every host version will be capable of generating code for every kind of target. So, in the future, the architecture and execution environment flag will become much more relevant than it is at the moment.
a)/STUB (Stub Program)
...
1.Debugging and Profiling

1.File Location
These flags tell the compiler where to look for and create files of a certain type.
There is a different flag in this category for each type of file. The flag must have a flag parameter, which must be a path. This path specifies the directory in which to look for or to create files of that type. Two or more paths can be specified, separated by ';' semicolons, in which case the paths are all searched, in the order specified, for files of that type — files are created in the directory specified by the first path.
The following table lists each of the flags in this category.

Flag	File Type	Default Location	
/SRC	Ada source files	current directory	
/LU	library unit files	current directory	
/EXE	executable files	current directory	
/DLL	dynamically linked library files 	current directory	
/DBG	debugging information files 	current directory	
/OBJ	COFF object files 	current directory	
/LIB	statically linked library files 	current directory	
/LST	source listing files 	current directory	
/ASM	assembly listing files 	current directory	
/MAP	map files 	current directory	

1.Filename Extension Settings
These flags set the filename extensions which the compiler associates with different file types. Each flag in this category must have a flag parameter, which specifies the extension (or extensions).
Any extension specified must obey the restrictions imposed by the operating system (if any). For Windows, this is (currently) the same as for DOS: one to three characters; each character must be a letter, digit, or one of a few allowed special characters (see Windows or DOS documentation for details). Wildcard characters are not allowed.
There is one flag in this category for each file type. The flags are given in the following table.

Flag	File Type	Default Extension	
/SRCEXT	Ada source files	ADA	
/LUEXT	library unit files	LU	
/EXEEXT	executable files	EXE	
/DLLEXT	dynamically linked library files	DLL	
/OBJEXT	COFF object files	OBJ	
/LIBEXT	statically linked library files	LIB	
/BCEXT	build control files	BC	
/DBGEXT	debugging information files	DBG	
/ASMEXT	assembly listing files	ASM	
/LSTEXT	source listing files	LST	
/ARGEXT	argument files	TXT	

As an example, supposing we needed to use a different extension for debugging information files to the default "DBG" (perhaps because that extension was already used for some other purpose on our machine). We could use the flag
/DBGEXT=DEB
to tell the compiler to create debugging information files with the extension "DEB" instead. Note that we would then have to tell the debugger to use this extension (see the debugger's documentation for details).
Two or more extensions can be specified (separated by a ';' semicolon) for a particular file type. In this case, the first specified extension is used when creating a file of that type, but the other extensions are also used (in the order specified) when searching for files of that type.
For example, the flag
/SRCEXT=ADA;ADS;ADB
would enable the compiler to search (automatically) for Ada source files which have any one of the three specified extensions ("ADA", "ADS", or "ADB"). In this example, the question of the creation of files does not arise, since the compiler never creates Ada source files.
It should be noted that the filename extension settings flags will very, very rarely need to be used. It is usually inadvisable to use different extensions to the defaults. Windows has some fairly fixed expectations about filename extensions; for example, Windows will simply refuse to even try to execute a file unless it has the extension "EXE".
The exact effect of the filename extension setting for each of the various file types is described as appropriate throughout this document.
Beware that in some documentation the term 'file type' is actually used to mean 'filename extension'.


a)/EC
Editor context file.
If this flag is followed by a non-alphanumeric character (the "=" character is usual) and then a string, the string is interpreted as follows. If the string is a pathname, it is taken to be the pathname of an editor context file. If it is a path, then it plus the string "DEFAULT.EC1" is taken to be the name of an editor context file. If there is no string, then "DEFAULT.EC1" (in the current directory on the current drive) is taken to be the name of an editor context file.
In every case, the specified editor context file is opened and updated as follows.
…

1.Help
There are three forms of a flag which causes the compiler program to output a list describing the various arguments and flags it will accept (and to do nothing else). Beware: if one of these flags is specified, any other arguments (flags or other) are silently ignored. The three forms of help flag are:
/HELP
/H
/?
This flag does not take a flag parameter, but if one is specified it is simply ignored.
I.Environment Variables
EDCON
ADALOG
ADALIB
ADAOUT
I.Customer Support
This chapter describes the various aspects of ThoughtWing's customer support programme.
A.Questions
We aim to accompany our products with the highest quality, comprehensive documentation. Of course, this is a tall order, and we cannot expect to achieve perfection first time.
If you have a question about one of our products, the accompanying documentation should always be your first recourse. Sometimes, other documentation may contain the information you need.
We will endeavour to provide support to customers who have not been able to find an answer in our documentation (or other appropriate documentation). We can be contacted by any of the methods described in section 7.5.
However, please bear in mind that we are a very small company, and it may sometimes take a little time for us to get back to you with a solution.
We would like to cordially request all our customers to please remain courteous when liaising with our staff. Happily, we find that the vast majority of our customers are always so. This matters a lot to us.
A.Faults
At ThoughtWing, we really pride ourselves on the quality of our products.
If you discover a fault of any kind in a ThoughtWing product, please follow this procedure:
1.Check to make absolutely sure that the fault exists, that it is actually a part of or caused by a ThoughtWing product, and that it does not have an obvious (proper) remedy;
2.Gather together as much information as you can regarding the fault, and make sure that this information is all put into written form;
3.Contact us using any of the methods described in section 7.5.
If you have discovered cures or workarounds for the fault, please also describe these to us.
We would like to emphasise that we need to be informed about faults of any kind whatsoever. This includes, for example:
faults in the documentation (even misspellings or solecisms);
inadequacies in the warnings and errors produced by the compiler;
slowness or excessive burden on the host equipment;
poor code generation;
anything which could be irritating, or even offensive, to a user of the product.
These are just a few examples.
If the fault you describe is genuine (and reproducible), we guarantee that we will either promptly fix the fault, and supply the remedy to you at no cost, or (if we cannot do this) refund you in full for the price you paid for the product. This guarantee does not apply to completely trivial faults.
We regret that we are not able to provide any guarantee against any kind of consequential loss as a result of the failure or characteristics of any of our products. Also, we cannot accept responsibility for faults in other parties' products which affect the operation or quality of our own.
A.Comments
Something that every business absolutely must have, if it is to thrive, is customer feedback. We need you to contact us! We are a small company, and we need our customers' support. In return, we aim to provide you with the highest quality products, at a low price.
If you have any comments to make about any of our products, please don't hesitate to contact us (by any of the methods described in section 7.5). We really appreciate all comments received from our customers, be they praise or criticism. This is the only way we have to further improve our products, so comments are precious to us.
A.Sales Enquiries
Please contact us (by any of the methods described in section 7.5) if you have any sales enquiries. We will get back to you as quickly as we can (remember we are a very small company).
A.How to Contact Us
To contact us, you can use any of the following methods:
E-mail: Nick.Roberts@dial.pipex.com
Fax or Voice-Mail: +181-405 1124
Post: ThoughtWing Software, 3 Brambledown Road, South Croydon, CR2 0BN, UK
We prefer e-mail.


</body>
</html>

